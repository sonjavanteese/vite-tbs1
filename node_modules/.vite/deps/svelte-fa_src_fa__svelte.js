import {
  SvelteComponentDev,
  add_location,
  append_dev,
  append_styles,
  attr_dev,
  detach_dev,
  dispatch_dev,
  empty,
  init,
  insert_dev,
  noop,
  null_to_empty,
  safe_not_equal,
  svg_element,
  validate_slots
} from "./chunk-K6MJRMI7.js";
import "./chunk-DFKQJ226.js";

// node_modules/svelte-fa/src/utils.js
var parseNumber = parseFloat;
function joinCss(obj, separator = ";") {
  let texts;
  if (Array.isArray(obj)) {
    texts = obj.filter((text) => text);
  } else {
    texts = [];
    for (const prop in obj) {
      if (obj[prop]) {
        texts.push(`${prop}:${obj[prop]}`);
      }
    }
  }
  return texts.join(separator);
}
function getStyles(style, size, pull, fw) {
  let float;
  let width;
  const height = "1em";
  let lineHeight;
  let fontSize;
  let textAlign;
  let verticalAlign = "-.125em";
  const overflow = "visible";
  if (fw) {
    textAlign = "center";
    width = "1.25em";
  }
  if (pull) {
    float = pull;
  }
  if (size) {
    if (size == "lg") {
      fontSize = "1.33333em";
      lineHeight = ".75em";
      verticalAlign = "-.225em";
    } else if (size == "xs") {
      fontSize = ".75em";
    } else if (size == "sm") {
      fontSize = ".875em";
    } else {
      fontSize = size.replace("x", "em");
    }
  }
  return joinCss([
    joinCss({
      float,
      width,
      height,
      "line-height": lineHeight,
      "font-size": fontSize,
      "text-align": textAlign,
      "vertical-align": verticalAlign,
      "transform-origin": "center",
      overflow
    }),
    style
  ]);
}
function getTransform(scale, translateX, translateY, rotate, flip, translateTimes = 1, translateUnit = "", rotateUnit = "") {
  let flipX = 1;
  let flipY = 1;
  if (flip) {
    if (flip == "horizontal") {
      flipX = -1;
    } else if (flip == "vertical") {
      flipY = -1;
    } else {
      flipX = flipY = -1;
    }
  }
  return joinCss(
    [
      `translate(${parseNumber(translateX) * translateTimes}${translateUnit},${parseNumber(translateY) * translateTimes}${translateUnit})`,
      `scale(${flipX * parseNumber(scale)},${flipY * parseNumber(scale)})`,
      rotate && `rotate(${rotate}${rotateUnit})`
    ],
    " "
  );
}

// node_modules/svelte-fa/src/fa.svelte
var file = "C:/xampp/htdocs/git/svelte/vite/app-dev-c/vite-tbs1/node_modules/svelte-fa/src/fa.svelte";
function add_css(target) {
  append_styles(target, "svelte-xj8byo", ".spin.svelte-xj8byo{animation:svelte-xj8byo-spin 2s 0s infinite linear}.pulse.svelte-xj8byo{animation:svelte-xj8byo-spin 1s infinite steps(8)}@keyframes svelte-xj8byo-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmEuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJEQSxLQUFBLGNBQUEsQ0FBQSxBQUNFLFNBQUEsQ0FBQSxrQkFBQSxDQUFBLEVBQUEsQ0FBQSxFQUFBLENBQUEsUUFBQSxDQUFBLE1BQXFDLEFBQ3ZDLENBQUEsQUFFQSxNQUFBLGNBQUEsQ0FBQSxBQUNFLFNBQUEsQ0FBQSxrQkFBQSxDQUFBLEVBQUEsQ0FBQSxRQUFBLENBQUEsTUFBQSxDQUFBLENBQW9DLEFBQ3RDLENBQUEsQUFFQSxXQUFBLGtCQUFBLENBQUEsQUFDRSxFQUFBLEFBQUEsQ0FBQSxBQUNFLFNBQUEsQ0FBQSxPQUFBLElBQUEsQ0FBdUIsQUFDekIsQ0FBQSxBQUNBLElBQUEsQUFBQSxDQUFBLEFBQ0UsU0FBQSxDQUFBLE9BQUEsTUFBQSxDQUF5QixBQUMzQixDQUFBLEFBQ0YsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJmYS5zdmVsdGUiXX0= */");
}
function create_if_block(ctx) {
  let svg;
  let g1;
  let g0;
  let g1_transform_value;
  let g1_transform_origin_value;
  let svg_class_value;
  let svg_viewBox_value;
  function select_block_type(ctx2, dirty) {
    if (typeof /*i*/
    ctx2[7][4] == "string")
      return create_if_block_1;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      g1 = svg_element("g");
      g0 = svg_element("g");
      if_block.c();
      attr_dev(
        g0,
        "transform",
        /*transform*/
        ctx[10]
      );
      add_location(g0, file, 92, 6, 1470);
      attr_dev(g1, "transform", g1_transform_value = `translate(${/*i*/
      ctx[7][0] / 2} ${/*i*/
      ctx[7][1] / 2})`);
      attr_dev(g1, "transform-origin", g1_transform_origin_value = `${/*i*/
      ctx[7][0] / 4} 0`);
      add_location(g1, file, 88, 4, 1359);
      attr_dev(
        svg,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(svg, "class", svg_class_value = null_to_empty(
        /*c*/
        ctx[8]
      ) + " svelte-xj8byo");
      attr_dev(
        svg,
        "style",
        /*s*/
        ctx[9]
      );
      attr_dev(svg, "viewBox", svg_viewBox_value = `0 0 ${/*i*/
      ctx[7][0]} ${/*i*/
      ctx[7][1]}`);
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "role", "img");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file, 79, 2, 1196);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, g1);
      append_dev(g1, g0);
      if_block.m(g0, null);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(g0, null);
        }
      }
      if (dirty & /*transform*/
      1024) {
        attr_dev(
          g0,
          "transform",
          /*transform*/
          ctx2[10]
        );
      }
      if (dirty & /*i*/
      128 && g1_transform_value !== (g1_transform_value = `translate(${/*i*/
      ctx2[7][0] / 2} ${/*i*/
      ctx2[7][1] / 2})`)) {
        attr_dev(g1, "transform", g1_transform_value);
      }
      if (dirty & /*i*/
      128 && g1_transform_origin_value !== (g1_transform_origin_value = `${/*i*/
      ctx2[7][0] / 4} 0`)) {
        attr_dev(g1, "transform-origin", g1_transform_origin_value);
      }
      if (dirty & /*id*/
      1) {
        attr_dev(
          svg,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (dirty & /*c*/
      256 && svg_class_value !== (svg_class_value = null_to_empty(
        /*c*/
        ctx2[8]
      ) + " svelte-xj8byo")) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (dirty & /*s*/
      512) {
        attr_dev(
          svg,
          "style",
          /*s*/
          ctx2[9]
        );
      }
      if (dirty & /*i*/
      128 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*i*/
      ctx2[7][0]} ${/*i*/
      ctx2[7][1]}`)) {
        attr_dev(svg, "viewBox", svg_viewBox_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(79:0) {#if i[4]}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let path0;
  let path0_d_value;
  let path0_fill_value;
  let path0_fill_opacity_value;
  let path0_transform_value;
  let path1;
  let path1_d_value;
  let path1_fill_value;
  let path1_fill_opacity_value;
  let path1_transform_value;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr_dev(path0, "d", path0_d_value = /*i*/
      ctx[7][4][0]);
      attr_dev(path0, "fill", path0_fill_value = /*secondaryColor*/
      ctx[3] || /*color*/
      ctx[1] || "currentColor");
      attr_dev(path0, "fill-opacity", path0_fill_opacity_value = /*swapOpacity*/
      ctx[6] != false ? (
        /*primaryOpacity*/
        ctx[4]
      ) : (
        /*secondaryOpacity*/
        ctx[5]
      ));
      attr_dev(path0, "transform", path0_transform_value = `translate(${/*i*/
      ctx[7][0] / -2} ${/*i*/
      ctx[7][1] / -2})`);
      add_location(path0, file, 100, 10, 1722);
      attr_dev(path1, "d", path1_d_value = /*i*/
      ctx[7][4][1]);
      attr_dev(path1, "fill", path1_fill_value = /*primaryColor*/
      ctx[2] || /*color*/
      ctx[1] || "currentColor");
      attr_dev(path1, "fill-opacity", path1_fill_opacity_value = /*swapOpacity*/
      ctx[6] != false ? (
        /*secondaryOpacity*/
        ctx[5]
      ) : (
        /*primaryOpacity*/
        ctx[4]
      ));
      attr_dev(path1, "transform", path1_transform_value = `translate(${/*i*/
      ctx[7][0] / -2} ${/*i*/
      ctx[7][1] / -2})`);
      add_location(path1, file, 106, 10, 1983);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path0, anchor);
      insert_dev(target, path1, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*i*/
      128 && path0_d_value !== (path0_d_value = /*i*/
      ctx2[7][4][0])) {
        attr_dev(path0, "d", path0_d_value);
      }
      if (dirty & /*secondaryColor, color*/
      10 && path0_fill_value !== (path0_fill_value = /*secondaryColor*/
      ctx2[3] || /*color*/
      ctx2[1] || "currentColor")) {
        attr_dev(path0, "fill", path0_fill_value);
      }
      if (dirty & /*swapOpacity, primaryOpacity, secondaryOpacity*/
      112 && path0_fill_opacity_value !== (path0_fill_opacity_value = /*swapOpacity*/
      ctx2[6] != false ? (
        /*primaryOpacity*/
        ctx2[4]
      ) : (
        /*secondaryOpacity*/
        ctx2[5]
      ))) {
        attr_dev(path0, "fill-opacity", path0_fill_opacity_value);
      }
      if (dirty & /*i*/
      128 && path0_transform_value !== (path0_transform_value = `translate(${/*i*/
      ctx2[7][0] / -2} ${/*i*/
      ctx2[7][1] / -2})`)) {
        attr_dev(path0, "transform", path0_transform_value);
      }
      if (dirty & /*i*/
      128 && path1_d_value !== (path1_d_value = /*i*/
      ctx2[7][4][1])) {
        attr_dev(path1, "d", path1_d_value);
      }
      if (dirty & /*primaryColor, color*/
      6 && path1_fill_value !== (path1_fill_value = /*primaryColor*/
      ctx2[2] || /*color*/
      ctx2[1] || "currentColor")) {
        attr_dev(path1, "fill", path1_fill_value);
      }
      if (dirty & /*swapOpacity, secondaryOpacity, primaryOpacity*/
      112 && path1_fill_opacity_value !== (path1_fill_opacity_value = /*swapOpacity*/
      ctx2[6] != false ? (
        /*secondaryOpacity*/
        ctx2[5]
      ) : (
        /*primaryOpacity*/
        ctx2[4]
      ))) {
        attr_dev(path1, "fill-opacity", path1_fill_opacity_value);
      }
      if (dirty & /*i*/
      128 && path1_transform_value !== (path1_transform_value = `translate(${/*i*/
      ctx2[7][0] / -2} ${/*i*/
      ctx2[7][1] / -2})`)) {
        attr_dev(path1, "transform", path1_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path0);
      if (detaching)
        detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(100:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let path;
  let path_d_value;
  let path_fill_value;
  let path_transform_value;
  const block = {
    c: function create() {
      path = svg_element("path");
      attr_dev(path, "d", path_d_value = /*i*/
      ctx[7][4]);
      attr_dev(path, "fill", path_fill_value = /*color*/
      ctx[1] || /*primaryColor*/
      ctx[2] || "currentColor");
      attr_dev(path, "transform", path_transform_value = `translate(${/*i*/
      ctx[7][0] / -2} ${/*i*/
      ctx[7][1] / -2})`);
      add_location(path, file, 94, 10, 1534);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*i*/
      128 && path_d_value !== (path_d_value = /*i*/
      ctx2[7][4])) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*color, primaryColor*/
      6 && path_fill_value !== (path_fill_value = /*color*/
      ctx2[1] || /*primaryColor*/
      ctx2[2] || "currentColor")) {
        attr_dev(path, "fill", path_fill_value);
      }
      if (dirty & /*i*/
      128 && path_transform_value !== (path_transform_value = `translate(${/*i*/
      ctx2[7][0] / -2} ${/*i*/
      ctx2[7][1] / -2})`)) {
        attr_dev(path, "transform", path_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(94:8) {#if typeof i[4] == 'string'}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let if_block_anchor;
  let if_block = (
    /*i*/
    ctx[7][4] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*i*/
        ctx2[7][4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Fa", slots, []);
  let { class: clazz = "" } = $$props;
  let { id = "" } = $$props;
  let { style = "" } = $$props;
  let { icon } = $$props;
  let { size = "" } = $$props;
  let { color = "" } = $$props;
  let { fw = false } = $$props;
  let { pull = "" } = $$props;
  let { scale = 1 } = $$props;
  let { translateX = 0 } = $$props;
  let { translateY = 0 } = $$props;
  let { rotate = "" } = $$props;
  let { flip = false } = $$props;
  let { spin = false } = $$props;
  let { pulse = false } = $$props;
  let { primaryColor = "" } = $$props;
  let { secondaryColor = "" } = $$props;
  let { primaryOpacity = 1 } = $$props;
  let { secondaryOpacity = 0.4 } = $$props;
  let { swapOpacity = false } = $$props;
  let i;
  let c;
  let s;
  let transform;
  $$self.$$.on_mount.push(function() {
    if (icon === void 0 && !("icon" in $$props || $$self.$$.bound[$$self.$$.props["icon"]])) {
      console.warn("<Fa> was created without expected prop 'icon'");
    }
  });
  const writable_props = [
    "class",
    "id",
    "style",
    "icon",
    "size",
    "color",
    "fw",
    "pull",
    "scale",
    "translateX",
    "translateY",
    "rotate",
    "flip",
    "spin",
    "pulse",
    "primaryColor",
    "secondaryColor",
    "primaryOpacity",
    "secondaryOpacity",
    "swapOpacity"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Fa> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(11, clazz = $$props2.class);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("style" in $$props2)
      $$invalidate(12, style = $$props2.style);
    if ("icon" in $$props2)
      $$invalidate(13, icon = $$props2.icon);
    if ("size" in $$props2)
      $$invalidate(14, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("fw" in $$props2)
      $$invalidate(15, fw = $$props2.fw);
    if ("pull" in $$props2)
      $$invalidate(16, pull = $$props2.pull);
    if ("scale" in $$props2)
      $$invalidate(17, scale = $$props2.scale);
    if ("translateX" in $$props2)
      $$invalidate(18, translateX = $$props2.translateX);
    if ("translateY" in $$props2)
      $$invalidate(19, translateY = $$props2.translateY);
    if ("rotate" in $$props2)
      $$invalidate(20, rotate = $$props2.rotate);
    if ("flip" in $$props2)
      $$invalidate(21, flip = $$props2.flip);
    if ("spin" in $$props2)
      $$invalidate(22, spin = $$props2.spin);
    if ("pulse" in $$props2)
      $$invalidate(23, pulse = $$props2.pulse);
    if ("primaryColor" in $$props2)
      $$invalidate(2, primaryColor = $$props2.primaryColor);
    if ("secondaryColor" in $$props2)
      $$invalidate(3, secondaryColor = $$props2.secondaryColor);
    if ("primaryOpacity" in $$props2)
      $$invalidate(4, primaryOpacity = $$props2.primaryOpacity);
    if ("secondaryOpacity" in $$props2)
      $$invalidate(5, secondaryOpacity = $$props2.secondaryOpacity);
    if ("swapOpacity" in $$props2)
      $$invalidate(6, swapOpacity = $$props2.swapOpacity);
  };
  $$self.$capture_state = () => ({
    joinCss,
    getStyles,
    getTransform,
    clazz,
    id,
    style,
    icon,
    size,
    color,
    fw,
    pull,
    scale,
    translateX,
    translateY,
    rotate,
    flip,
    spin,
    pulse,
    primaryColor,
    secondaryColor,
    primaryOpacity,
    secondaryOpacity,
    swapOpacity,
    i,
    c,
    s,
    transform
  });
  $$self.$inject_state = ($$props2) => {
    if ("clazz" in $$props2)
      $$invalidate(11, clazz = $$props2.clazz);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("style" in $$props2)
      $$invalidate(12, style = $$props2.style);
    if ("icon" in $$props2)
      $$invalidate(13, icon = $$props2.icon);
    if ("size" in $$props2)
      $$invalidate(14, size = $$props2.size);
    if ("color" in $$props2)
      $$invalidate(1, color = $$props2.color);
    if ("fw" in $$props2)
      $$invalidate(15, fw = $$props2.fw);
    if ("pull" in $$props2)
      $$invalidate(16, pull = $$props2.pull);
    if ("scale" in $$props2)
      $$invalidate(17, scale = $$props2.scale);
    if ("translateX" in $$props2)
      $$invalidate(18, translateX = $$props2.translateX);
    if ("translateY" in $$props2)
      $$invalidate(19, translateY = $$props2.translateY);
    if ("rotate" in $$props2)
      $$invalidate(20, rotate = $$props2.rotate);
    if ("flip" in $$props2)
      $$invalidate(21, flip = $$props2.flip);
    if ("spin" in $$props2)
      $$invalidate(22, spin = $$props2.spin);
    if ("pulse" in $$props2)
      $$invalidate(23, pulse = $$props2.pulse);
    if ("primaryColor" in $$props2)
      $$invalidate(2, primaryColor = $$props2.primaryColor);
    if ("secondaryColor" in $$props2)
      $$invalidate(3, secondaryColor = $$props2.secondaryColor);
    if ("primaryOpacity" in $$props2)
      $$invalidate(4, primaryOpacity = $$props2.primaryOpacity);
    if ("secondaryOpacity" in $$props2)
      $$invalidate(5, secondaryOpacity = $$props2.secondaryOpacity);
    if ("swapOpacity" in $$props2)
      $$invalidate(6, swapOpacity = $$props2.swapOpacity);
    if ("i" in $$props2)
      $$invalidate(7, i = $$props2.i);
    if ("c" in $$props2)
      $$invalidate(8, c = $$props2.c);
    if ("s" in $$props2)
      $$invalidate(9, s = $$props2.s);
    if ("transform" in $$props2)
      $$invalidate(10, transform = $$props2.transform);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*icon*/
    8192) {
      $:
        $$invalidate(7, i = icon && icon.icon || [0, 0, "", [], ""]);
    }
    if ($$self.$$.dirty & /*clazz, spin, pulse*/
    12584960) {
      $:
        $$invalidate(8, c = joinCss([clazz, "svelte-fa", spin && "spin", pulse && "pulse"], " "));
    }
    if ($$self.$$.dirty & /*style, size, pull, fw*/
    118784) {
      $:
        $$invalidate(9, s = getStyles(style, size, pull, fw));
    }
    if ($$self.$$.dirty & /*scale, translateX, translateY, rotate, flip*/
    4063232) {
      $:
        $$invalidate(10, transform = getTransform(scale, translateX, translateY, rotate, flip, 512));
    }
  };
  return [
    id,
    color,
    primaryColor,
    secondaryColor,
    primaryOpacity,
    secondaryOpacity,
    swapOpacity,
    i,
    c,
    s,
    transform,
    clazz,
    style,
    icon,
    size,
    fw,
    pull,
    scale,
    translateX,
    translateY,
    rotate,
    flip,
    spin,
    pulse
  ];
}
var Fa = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        class: 11,
        id: 0,
        style: 12,
        icon: 13,
        size: 14,
        color: 1,
        fw: 15,
        pull: 16,
        scale: 17,
        translateX: 18,
        translateY: 19,
        rotate: 20,
        flip: 21,
        spin: 22,
        pulse: 23,
        primaryColor: 2,
        secondaryColor: 3,
        primaryOpacity: 4,
        secondaryOpacity: 5,
        swapOpacity: 6
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Fa",
      options,
      id: create_fragment.name
    });
  }
  get class() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fw() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fw(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pull() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pull(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scale() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scale(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateX() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateX(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get translateY() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set translateY(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rotate() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rotate(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flip() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flip(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pulse() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pulse(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryColor() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryColor(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryColor() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryColor(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get primaryOpacity() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set primaryOpacity(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get secondaryOpacity() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set secondaryOpacity(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get swapOpacity() {
    throw new Error("<Fa>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set swapOpacity(value) {
    throw new Error("<Fa>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var fa_default = Fa;
export {
  fa_default as default
};
//# sourceMappingURL=svelte-fa_src_fa__svelte.js.map
